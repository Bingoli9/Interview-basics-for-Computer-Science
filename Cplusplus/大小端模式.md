## 大小端模式

大端模式(big endian)和小端模式(little endian)。
在我们发送数据的时候，我们首先要确定是大端还是小端模式来进行的，在接收方接收的数据必须知道数据是大端还是小端模式，才能正确地读取和存储数据起来，否则就会出错。
一个32位的二进制在内存中的存储时有2种分布方式：高字节对应高字节（大端模式）、高字节对应低地址（小端模式）。
有些时候CPU公司用大端（C51单片机）；有些CPU用小端（ARM）。我们写代码的时候需要通过写代码来测试当前系统是大端还是小端模式。

方法1：用union来测试机器的大小端模式：共用体中很重要的一点：a和b都是从共用体的低地址开始的，我们在共用体的int变量中写入1，通过读取该共用体的char类型变量，如果该char值为1，说明数据是低地址对应低字节（小端），如果该char值是0，则说明是从低地址对应高字节（大端）。

```c++
//大小端模式的判断
//方法一：利用联合体所有成员的起始位置一致，
//对联合体中的int类型赋值，然后判断联合体中char类型的值的大小

void SysCheck()
{
	union IsLitte_Endian
	{
		int i;
		char c;
	};
	IsLitte_Endian Check;
	Check.i = 1;
	bool Flag=Check.c == 1;	//Flag为true表示是小端模式，Flag为false表示为大端模式，此时Flag为true。
	return;
}
```

方法2：用指针方式来测试机器的大小端：其实本质上和union没有差多少，就是定义一个int a = 1;然后定义一个char b来指向a的首地址，然后通过b的值来判断是大端还是小端模式；如果b=1，说明a的存储方式是0001，即低字节存在低地址（小端）；如果b=0，说明a的存储方式是1000，即高字节存在低地址（大端）。
解析：*(char *)(&a);首先对a取地址，将改地址强制转换为(char *)的类型，然后再解引用得出改地址中的内容。

```c++
int is_little_endian2(void)
{
int a = 1;
char b = *(char *)(&a);
return b;
}
```

**看似可行实际不行的方法**：
1.位与运算：位与运算时编译器提供的运算，这个运算是高于内存层次的，因为在进行位与运算的时候，一定是高字节 & 高字节的，所以无法判断出到底是大端还是小端模式。
2.移位：与位与运算一样，右移运算永远是将低字节移除，而和二进制存储时这个低字节在高位还是低位是无关的。
3.强制类型转换：与1、2同理。