## 模板

模板：函数模板和类模板可以使程序员只需指定一个单独的代码段，就可以表示一整套称为类模板特化的重载函数或是表示一整套称为类模板特化的相关的类。这种结束称为泛型程序设计。

函数模板：重载的函数通常对不同类型的数据进行相同的或者相似的操作，程序员只需要写一个单函数模板的定义，它通过**显式或隐式提供的实参类型进行函数调用**，而**编译器**产生不同**的目标代码函**数来适当地处理每个函数调用。

模板形参名只能在模板头部的参数列表中声明一次，但是可以在函数头和函数体内重复使用。**函数模板形参名不必是唯一的。**

重载函数模板：**编译器使用重载的方式来调用适当的函数**。**一个函数模板可以被一个具有相同函数名但不同函数参数的非模板函数所重载**。编译器在函数调用是进行匹配处理来决定调用哪个函数。首先，编译器会找出所有和调用函数名匹配的函数模板，然后根据调用函数的参数类型对函数模板进行特化，接着编译器找出所有与调用函数里的普通函数想匹配的函数。

类模板：

类模板的**非类型参数**：**非类型参数可以作为默认的参数并作常量处理**。

**默认类型参数**：作为模板的默认类型，必须在模板参数列表的最右边。当用两个或两个以上的默认类型初始化一个类时，**如果其中一个默认参数不是在模板参数列表的右边，那么该参数右边的所有参数都将被忽。**

模板和静态成员的注意事项：一个静态数据成员的副本将被所有类的对象共享，并且**静态数据成员都必须在文件范围内初始化。**

每一个有相同类模板实例化产生的**类模板特化都有它自己的类模板静态成员和数据成员的副本**。一个模板类特化产生的**所有对象都共享一个静态数据成员**。另外，和非模板类的静态成员一样，类模板特化的静态成员数据必须被定义，并且尽可能在文件范围内初始化。每**一个类模板特化都将得到一份属于它自己的类模板静态成员函数的副本**。



### 模板和友元函数注意事项

假定名为X的类定义了一个包含单个类型参数T的类模板。

template <typename T> class X;

1. 构造一个是所有从类X的类模板实例化得到的类模板特化的友元函数f1

   friend void f1()

2. 构造一个仅仅包含相同类型参数的类模板特化的友元函数

   friend void f2(X<T> &)

3. 将一个其他类的成员函数声明为一个类模板产生的所有类模板特化的友元。

   friend void A::f3()

4. 对于一个全局函数，另一个类的成员函数只能包含相同类型参数的类模板特化的友元。

   friend void A::f4(X<T> &)

5. 将整个类的成员函数设定为类模板的友元。

   friend class Y;

6. 是一个类模板特化的所有成员都成为一个包含相同类型参数的类模板特化的友元。

   friend class Y<T>


