## 多态性

类继承层次中对象之间的关系：派生类的对象可以当成它的基类对象进行处理，因此可以创建基类指针的数组，数组元素指向许多派生类对象。尽管事实上派生类对象和基类对象是不同的类型，但编译器允许这种操作，因为每个派生类对象都是一个基类对象。然而，不能把基类对象当成任何一个派生类对象处理。

### **从派生类对象调用基类函数：**

1、将基类指针指向基类对象

2、将派生类指针指向派生类对象，并调用派生类的功能。

3、通过基类对象指向派生类对象。

**从派生类指针指向基类对象：**

把派生类对象的地址赋给了基类指针，C++编译器允许这种赋值的原因：每个派生类对象都是一个基类对象。但编译器不允许将基类对象的地址赋值给派生类对象，基类对象不是派生类对象。

### **通过基类指针调用派生类的成员函数**

利用基类指针，编译器允许调用基类的成员函数。因此，如果基类指针指向了派生类对象，并且视图访问只在派生类中拥有的成员函数，那么就会产生编译错误。

若希望通过指向派生类对象的基类指针访问只在派生类中拥有的成员，只要显式地把这样的基类指针强制类型转换为派生类指针，这就是向下强制类型转换计数。向下强制类型转换技术允许程序通过指向派生类对象的基类指针，执行只有派生类才拥有的操作。经过向下强制类型转换技术后，程序就可以调用基类中没有的派生类函数。

### **virtual 函数**

virtual函数：不用虚函数的话，句柄类型决定了哪个类的函数被调用的。如果利用virtual函数，调用哪个版本的virtual函数有句柄所指向的对象类型决定，而非句柄类型。

当virtual函数通过按名引用特定对象和使用圆点成员选择运算符的方式调用是，调用哪个函数在编译时已经决定了（称为静态绑定），所调用的virtual函数正是为该特定对象所属的类定义的函数，并不是多态性行为。因此，使用virtual函数进行动态绑定只能通过指针句柄来完成。

### **基类和派生类对象、指针之间允许的赋值操作概述**

基类指针指向派生类对象。这是一种安全的方式，因为派生类对象也是一个基类对象。然而，这一指针只能用来调用基类的成员函数。如果程序员视图利用该基类指针调用仅派生类含有的成员，则编译器会产生错误。为了避免这一错误，程序员必须把基类指针强制转换为派生类指针。之后，这个派生类指针可以用来调用派生类对象中的所有功能。

派生类指针指向基类对象。这种方式会产生编译错误。一个基类对象并不具有仅派生类才含有的成员。这些成员只能通过派生类指针调用。

### **抽象类和纯virtual函数**

抽象类和纯virtual函数：有些情况下，定义程序员永远不打算算实例化任何对象的类是有用的，这样的类称为抽象类。因为通常抽象类在类的继承层次结构中作为基类，所以我们称它们为抽象基类。

**构造抽象类的目的是为其他类提供适合的基类。可以用来实例化对象的类称为具体类**。具体类提供其定义每个成员函数的实现。

继承层次不需要包含任何抽象类，很多优秀的面向对象系统都有抽象基类打头的类继承层次。

**通过声明类的一个或多个virtual函数为纯virtual函数，可以是一个类成为抽象类**。一个纯virtual函数是在声明时初始化值为0的函数，如下所示：

virtual void draw() const = 0; //pure virtual function

**“=0”称为纯指示符。纯virtual函数不提供函数具体实现，每个派生的就具体类必须重写所有基类的纯virtual函数定义，提供这些函数具体实现。**

virtual函数和纯virtual函数的区别：virtual函数有函数的实现，并且提供派生类是否重写这些函数的选择全。相反，纯virtual函数并不提供函数的实现，需要派生类重写这些函数这些函数以使派生类成为具体类，否则派生类仍然是抽先类。

尽管不能实例化一个抽象基类，但是可以利用抽象基类声明指针和引用，是它们可以通过引用任何从抽象派生类的具体类的对象。程序通过利用这种指针和引用动态地操作派生类对象。

### **多态性、virtual函数和动态绑定的底层实现机制**

多态性通过三级指针实现的，即三级间接取值。

当C++编译含有一个或多个virtual函数的类时，它为这个类创建一个 virtual函数表。每次调用该类的virtual函数时，运行程序都会利用virtual函数表选择正确的函数实现。

对于纯虚函数，在虚函数表中，函数指针被设置成0（即空指针）。任何在其virtual函数表中含有一个或多个空指针的类都是抽象类。

第一级指针是虚函数表中指向具体对应函数的指针。

第二级指针是当实例化具有一个或多个virtual函数的类对象时，编译器给这个对象附上一个指针，指向对象所属类的virtual函数表。

第三级指针仅仅包含接收virtual函数调用的对象句柄。这个级别中句柄可以是引用。

**注意；**每次virtual函数调用时发生的指针间接引用操作和内存访问，都需要增加程序执行时间。而virtual函数表和加入对象的虚函数表指针也要占用额外的内存。

### **virtual析构函数**

如果删除一个具有非虚析构函数的派生类对象，却显式地通过指向该对象的一个基类指针，对它应用delete运算符，那么C++标准会指出这一行为未定义。

解决方法：在基类中创建virtual析构函数，这样，即使所有派生类的析构函数不与基类的析构函数同名，也可以使这些析构函数为virtual函数。现在，如果对一个基类指针用delete运算符来显式删除它所指的类层次中的某个对象，那么系统会根据该指针所指对象调用相应类的析构函数。记住，当一个派生类对象被销毁时，派生类对象中属于基类的部分也会被销毁，因此执行派生类和基类的析构函数很重要。基类的析构函数在派生类析构函数执行之后自动执行。

### **向下强制类型转换**

dynamic_cast运算符检查指针所指对象的类型，然后判断这一类型是否与次指针正在转换成的类型有一种”是一个“的关系。如果它们之间存在”是一个“关系，dynamic_cast返回对象的地址；如果没有，dynamic_cast返回0.



 