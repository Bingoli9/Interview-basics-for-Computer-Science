## c++中的悬浮指针和野指针 

（1） c++中的悬浮指针：声明了但没有被付值的指针，它指向内存中的任意一个空间。避免悬浮指针的一个方法是开始就付值为NULL

（2）“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。野指针的成因主要有两种：

一、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。**所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。**


二、**指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。**别看free和delete的名字恶狠狠的（尤其是delete），**它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。通常会用语句if (p != NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便p不是NULL指针**，它也不指向合法的内存块。例：

```c
　char *p = (char *) malloc(100);

　　strcpy(p, “hello”);

　　free(p); // p 所指的内存被释放，但是p所指的地址仍然不变

　　if(p != NULL) // 没有起到防错作用

　　strcpy(p, “world”); // 出错　　

```

**三、另外一个要注意的问题：不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。**strlen是对char*的，string不行，这个很容易让人误解啊

**四、我们易犯的错误：**

对于第二个错误很容易在C++中出现，比如在类的定义时的构造函数和析构函数，如果在构造函数中动态开辟（new），**在析构函数中要释放，然而我们一般都delete释放内存后就结束了，殊不知，指向先前内存的指针就成了野指针（迷途指针）**，稍有不慎，就会出错，当你向未知区域赋值时，运气好的话会是程序运行错误，要是运气不佳，很可能引起系统崩溃！

**解决方法：将将要指向未知区域的指针（刚定义的或是释放内存的指针）等于NULL或指向常量，使用指针之前再做判断null**

**无论在什么情况下delete之后是否要设置为NULL？唯一的判断标准就是以后会不会再用它， 如果以后有可能用，就一定设置为NULL，否则就不必， 除非是对软件的性能要求很强，否则尽管每次delete后都设置NULL好了**  这样做，永远是不会运行出错的， 潜在的后果就是，这个赋NULL值的操作，浪费了你万分之一秒不到的时间。

**五 、知识补充：**

一般我们常说的**内存泄漏是指堆内存的泄漏**。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显示释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，**否则，这块内存就不能被再次使用，我们就说这块内存泄漏了**





