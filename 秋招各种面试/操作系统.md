#### 线程间通信函数

1. wait(),notify(),以及notifyAll

   - wait()方法使得当前线程必须要等待，等到另外一个线程调用notify()或者notifyAll()方法。
   - notify()方法会唤醒一个等待当前对象的锁的线程。而notifyAll(）顾名思义；就是唤醒所有在等待中的方法；
   - wait()和notify()方法要求在调用时线程已经获得了对象的锁，因此对这两个方法的调用需要放在synchronized方法或synchronized块中。

2. await和signal/signalAll

   await和signal是Condition的两个方法，其作用和wait和notify一样，目的都是让线程挂起等待，不同的是，这两种方法是属于Condition的两个方法，而Condition对象是由ReentrantLock调用newCondition()方法得到的。Condition对象就相当于前面所说的中介，在线程中调用contiton.await()和condition.signal()可以分别使线程等待和唤醒。

   在使用Condition的时候和Synchronized没有太大的区别，只是调用的方法变为await和signal。需要注意的是这里加锁不再使用synchronized()进行加锁，而是使用lock和unlock进行加锁。

3. sleep/yield/join

   await和signal是Condition的两个方法，其作用和wait和notify一样，目的都是让线程挂起等待，不同的是，这两种方法是属于Condition的两个方法，而Condition对象是由ReentrantLock调用newCondition()方法得到的。Condition对象就相当于前面所说的中介，在线程中调用contiton.await()和condition.signal()可以分别使线程等待和唤醒。

4. Semaphore 信号量

   Semaphore在线程协作方面主要用于控制同时访问临界区资源的线程个数，根据结果可以看出只有当有线程释放资源之后，才会有新的线程获取到资源。即控制了同一时间访问临界区资源的线程数量。当Semaphore(1)设置为1的时候,此时可以当做锁来使用。

#### 线程能共享和独享的资源

- 堆 由于堆在进程空间开辟出来的。
- 全局变量 
- 静态变量
- 文件等公用资源

独享的资源有

- 栈
- 寄存器 寄存器是物理的，但线程存放的是副本，包括程序计数器PC

#### 进程的地址空间最大是多少

在32位机器上linux操作系统中的进程的地址空间大小是4G,其中0-3G是用户空间，3G-4G是内核空间**。其实，**这个4G的地址空间是不存在的，也就是我们所说的虚拟内存空间

因为在32位的操作系统中，一个指针长度是4字节，而4字节指针的寻址能力是从0x00000000~0xFFFFFFFF，最大值0xFFFFFFFF表示的即为4GB大小的容量

#### 多线程问题（怎么优化，减少负载，一次50000个请求）

https://blog.csdn.net/luofenghan/article/details/78596950

#### 线程池和连接池

线程池目的是减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。

“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。

所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。
对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。

#### 用户态和内核态

内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。

用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu能力被剥夺，cpu资源可以被其他程序获取。

#### 系统调用与库函数的区别？

系统调用：操作系统为用户程序与硬件设备进行交互提供的一组接口，发生在内核地址空间。

库函数：把一些常用的函数编写完放到一个文件里，编写应用程序时调用，这是由第三方提供的，发生在用户地址空间。

在移植性方面，不同操作系统的系统调用一般是不同的，移植性差；而在所有的ANSI C编译器版本中，C库函数是相同的。

在调用开销方面，系统调用需要在用户空间和内核环境间切换，开销较大；而库函数调用属于“过程调用”，开销较小。

#### 守护、僵尸、孤儿进程的概念

**守护进程：**运行在后台的一种特殊进程，独立于控制终端并周期性地执行某些任务。

**僵尸进程：**一个进程 fork 子进程，子进程退出，而父进程没有 `wait`/`waitpid`子进程，那么子进程的进程描述符仍保存在系统中，这样的进程称为僵尸进程。

**孤儿进程：**一个父进程退出，而它的一个或多个子进程还在运行，这些子进程称为孤儿进程。（孤儿进程将由 init 进程收养并对它们完成状态收集工作）

#### 分时系统与实时系统的区别？

- 分时系统：系统把CPU时间分成很短的时间片，轮流地分配给多个作业。优点：对多个用户的多个作业都能保证足够快的响应时间，并且有效提高了资源的利用率。
- 实时系统：系统对外部输入的信息，能够在规定的时间内（截止期限）处理完毕并做出反应。优点：能够集中地及时地处理并作出反应，高可靠性，安全性。



