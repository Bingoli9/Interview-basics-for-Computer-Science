#### 七层网络协议

应用层、表示层、会话层、传输层、网络层、链路层、物理层

#### IP层是否有连接状态，维护连接状态的是哪一层

IP层不维护，运输层的TCP维护连接状态。

#### 应用层-TCP-IP-链路层，各个层是什么包

1. 某进程(也就是在应用层)准备好待传输数据，若目的地址是域名则要先通过DNS解析成IP地址
2. 交付到运输层(TCP/UDP层)，运输层通过socket接口对数据进行适当的分组等操作，后对每一个分组数组加上首部形成报文段(或用户数据报)首部包括源地址、源端口、目的地址、目的端口和一些其他的诸如校验和等数据
3. 交付到网际层(IP层)，对分组数据加上首部形成IP数据报，首部包括源地址、目的地址(跟运输层的目的地址不同，运输层的目的地址是数据要传送的最终地址，而该目的地址是通过路由表信息得出，是该数据下一步该转移的目的计算机)和校验和等数据
4. 交付到数据链路层(mac层)，先是对把数据封装成帧(也就是添加首部[SOH]和尾部[EOT])，然后进行透明传输(也就是封装的数据里面，如果出现首部SOH和尾部EOT这样的数据，对其进行转义，也就是加上ESC转义字符，这种方法称为字节/字符填充)
5. 交付到物理层，根据数据链路层的mac知道要传输到目的计算机，通过特定的传输介质传送到下一个地址

#### TCP的三次握手 

第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； 
SYN：同步序列编号(Synchronize Sequence Numbers)
第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； 
第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.

#### 服务器网络请求的接口底层

http协议的底层是在应用层里,是一个特殊处理的socket,建立在TCP/IP协议之上的一种广泛应用

1. 服务器先初始化一个socket, 与端口绑定bind(), 对端口进行监听listen(), 调用阻塞,等待客户端的连接
2. 初始化客户端的socket,与服务器的socket连接,需要经过三次握手
3. 服务器将数据返回给客户端,客户端读取数据,显示在界面上
4. 客户端断开连接需要经过四次握手断开连接

很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。（心跳服务）

#### 四次挥手

1. 客户端向服务器发送一个带有结束标记的报文
2. 服务器接到报文后,向客户端发送一个确认号,同时通知自己相应的应用程序,对方要求断开连接
3. 服务器向客户端发送结束标记的报文
4. 客户端接收到报文后向服务器发送确认序号,断开连接

#### TimeWait状态发生在什么时候

客户机收到服务器带有结束标记的报文时，客户机会对它进行确认，发送响应报文，然后进入TimeWait的状态。

time_wait存在的原因有两点 
1.可靠的终止TCP连接。 
2.保证让迟来的TCP报文段有足够的时间被识别并丢弃。

1.可靠的终止TCP连接，若处于time_wait的client发送给server确认报文段丢失的话，server将在此又一次发送FIN报文段，那么client必须处于一个可接收的状态就是time_wait而不是close状态。 
2.保证迟来的TCP报文段有足够的时间被识别并丢弃，linux 中一个TCP port 不能打开两次或两次以上。当client处于time_wait状态时我们将无法使用此port建立新连接，假设不存在time_wait状态，新连接可能会收到旧连接的数据。

time_wait持续的时间是2MSL，保证旧的数据能够丢弃。由于网络中的数据最大存在MSL(maxinum segment lifetime)

怎样避免time_wait状态占用资源

#### TCP怎么进行可靠传输服务？怎么判断是否重传？（看书吧）

1. 超时
2. 收到3个相同的ack

#### TCP拥塞控制

#### RPC服务器和web服务器的区别，底层的不同（socket， TCP）

#### 服务端发送信息给客户端，要进行数据的序列化，客户端怎么判断哪些数据是在一起？数据是否传输完成？

数据的序列化:

每个包都有一个序列号，当发送方按顺序发出的包乱序到达接收方时（因为走的链路不同），乱序的包会放在接收方的缓存中，先处理按顺序最前的包，或者所有包到达后，重排序，再传给应用层

数据完整性：

头+包体+校验，头部信息可能包括总长度，然后自己接收计算，是否达到总长度

#### TCP的粘包和分包

#### http与https的区别

http协议以明文的方式发送内容，不提供任何方式的数据加密。https协议是安全套接字层超文本协议HTTPS，提供数据传输的安全。HTTPS 在http的基础上加上了SSL协议。

#### https工作原理

客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

- 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
- Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
- 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
- Web服务器利用自己的私钥解密出会话密钥。
- Web服务器利用会话密钥加密与客户端之间的通信。

<center>
    <img src = "https://github.com/leekeiling/Interview-basics-for-Computer-Science/blob/master/Computer%20Networks/picture/2012071410212142.gif?raw=true"/>
</center>

HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。



#### http状态码，301和302的区别。重定向的具体机制。

301 redirect: 301 代表永久性转移(Permanently Moved)

302 redirect: 302 代表暂时性转移(Temporarily Moved )

#### TCP三次握手，tcp六个标志位都是什么有什么用

- SYN(synchronous建立联机) 
- ACK(acknowledgement 确认) 
- PSH(push传送) 
- FIN(finish结束) 
- RST(reset重置) 
- URG(urgent紧急)

#### http报文具体结构了解吗，分哪几部分。几种访问请求说一下(get，post，put，patch，delete等)。那这几种哪几种是幂等性的呢。

#### Epoll，poll，select区别。Epoll为什么更快，讲一下具体机制。

1. 功能

   - select会修改描述符，而poll不会
   - select的描述符类型使用数组实现，默认是1024；poll的描述符类型使用链表实现，没有符号数量的限制。
   - poll提供了更多的事件类型，并且对描述符的重复利用比select高
   - 如果一个线程对某个描述符调用了select或者poll，另一个线程关闭了该描述符，会导致调用结果不确定。

2. 速度

   - select和poll每次调用都需要将全部描述符从应用程序缓冲区复制到内核缓冲区
   - select和poll的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于0时，应用进程都需要使用轮询的方式来找到IO完成的描述符。

3. 可移植性

   几乎所有的系统都支持select，只是比较新的系统支持poll

4. 关于epoll

   epoll会向内核注册新的描述符或者改变某个文件描述符的状态。已经注册的描述符在内核中会被维护成一颗红黑树，通过回调函数内核将IO准备好的描述符加入到一个链表中管理，进程调用epoll_wait便可以得到事件完成的描述符。



   epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。

#### IO模式种类

- 阻塞式IO
- 非阻塞式IO
- IO复用(select 和 poll)
- 信号驱动式 IO (SIGIO)
- 异步IO (AIO)

#### epoll的工作模式

1. LT模式

   当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。

2. ET模式

   通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。

   很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

#### HTTP方法

- get：获取资源
- head：获取报文首部
- post：传输实体主体
- put：上传文件
- patch：对资源进行部分修改
- delete：删除文件
- options: 查询支持的方法
- connect：要求在与代理服务器通信时建立隧道
- trace：追踪路径

#### P2P应用

文件分发、分布式散列表

#### UDP和TCP

DNS使用UDP而不是TCP原因：TCP建立连接的时延

HTTP使用TCP而不是UDP原因：对于WEB网页来说，关注可靠性。

使用UDP而不是TCP场景：

- 实时应用通常要求最小的发送速率，不希望过分地延迟报文段的传送，并且能容忍一些数据的丢失；另一方面，TCP的拥塞控制会导致视频等实时应用性能变得很差
- 无需连接建立，减少时延
- 无连接状态，对于某种特定应用的服务器来说，能支持更多的活跃用户
- 分组首部开销小

#### 媒体计数

视频性质：高比特率、可以压缩。

网络语音计数的模型：编码的目的是减少带宽占用，抖动缓冲区解决网络延迟一会儿大一会小的问题。

流式存储视频：分为3种类型：UDP流、HTTP流、适应性HTTP流。三种都使用了客户端应用缓存。 客户端一边播放一边从服务器接受该视频的后续部分。避免了在开始播放之前必须先下载整个视频（时延）。另外，缓存和预取为连续播放提供了保证。

- UDP流缺点：带宽变化不稳定导致恒定速率UDP流不能够提供连续的播放。
- HTTP流：建立TCP连接，发送HTTP GET请求，使用预取视频在客户应用缓存中
- 适应性HTTP流：视频编码有几个不同的版本，对应不同的比特率，根据用户的可用带宽来动态选择

音频视频会话应用：高度时延敏感、可以容忍丢包

#### TCP滑动窗口

用于流量控制，接收端告诉发送端自己还有多少缓冲区可以接收数据

- 接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;
- 而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。

#### TCP报文段结构

源端口号、目的端口号、序号、确认号、滑动窗口、标志字段

#### TCP 是一种提供可靠性交付的协议的几种技术：

1. 滑动窗口
2. 超时重传
3. 流量控制
4. 拥塞控制

#### TCP拥塞控制

- 慢启动
- 拥塞避免
- 拥塞发生时的快速重传

#### 网络层3组件

- IP协议
- 路由选择协议
- ICMP

#### ICMP协议

因特网控制报文协议，用途是差错报告。应用：ping、traceroute

#### 客户端不断进行请求链接

服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认，即为DDos攻击

DDos 攻击

#### DDos 攻击

- 客户端向服务端发送请求链接数据包
- 服务端向客户端发送确认数据包
- 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认。

#### DDos预防

- 限制同时打开SYN半链接的数目
- 缩短SYN半来凝结的Time out时间

#### marshal/unmarshal

将对象转为json、xml等格式为marshal

#### HTTP版本

HTTP1.0和HTTP1.1分别是短连接和长连接，http 2.0支持多路复用。Connection：Keep-Alive

#### 秒杀系统，面对高并发的抢购活动

- 前端常用的三板斧是【扩容】【静态化】【限流】

- 静态化：将活动页面上的所有可以静态的元素全部静态化，并尽量减少动态元素。通过CDN来抗峰值。

- 限流：一般都会采用IP级别的限流，即针对某一个IP，限制单位时间内发起的请求数量。或者活动入口的时候增加游戏或者问题环节进行消峰操作

- 针对后端的数据库在高并发下性能差和超卖问题，后端层面优化性能的思路：

  **解决方案1：**将存库从MySQL前移到Redis中，所有的写操作放到内存中，由于Redis中不存在锁故不会出现互相等待，并且由于Redis的写性能和读性能都远高于MySQL，这就解决了高并发下的性能问题。然后通过队列等异步手段，将变化的数据异步写入到DB中。

  优点：解决性能问题

  缺点：没有解决超卖问题，同时由于异步写入DB，存在某一时刻DB和Redis中数据不一致的风险。

  **解决方案2：**引入队列，然后将所有写DB操作在单队列中排队，完全串行处理。当达到库存阀值的时候就不在消费队列，并关闭购买功能。这就解决了超卖问题。

  优点：解决超卖问题，略微提升性能。

  缺点：性能受限于队列处理机处理性能和DB的写入性能中最短的那个，另外多商品同时抢购的时候需要准备多条队列。

#### [CDN](https://cloud.tencent.com/developer/article/1082339)

#### [高并发架构](https://cloud.tencent.com/developer/article/1138691)

高并发的服务需要有均衡负载，数据库需要主从集群，nosql 缓存需要主从集群，静态文件需要上传cdn

#### ping

ping就是给目标IP地址发送一个 ICMP 回显请求，并要求对方返回一个 ICMP 回显应答来确定两台网络机器是否连通，时延是多少 

#### ICMP

#### 差错检测和报告

#### 搜索引擎原理

从互联网上抓取网页→建立倒排索引数据s库→在索引数据库中搜索排序。 

#### TIME_WAIT状态的产生、危害、如何避免？

TCP协议在关闭连接的四次挥手中，为了应对最后一个 ACK 丢失的情况，Client（即主动关闭连接的一方）需要维持 time_wait 状态并停留 2 个MSL的时间。 **危害：**Linux分配给一个用户的文件句柄是有限的，如果系统中存在大量的 time_wait 状态，一旦达到句柄数上限，新的请求就无法被处理了，而且大量 time_wait 连接占用资源影响性能。 **如何避免：**在`/etc/sysctl.conf`文件中开启 `net.ipv4.tcp_tw_reuse`重用和`net.ipv4.tcp_tw_recycle`快速回收。

#### 为什么 TCP 叫数据流模式？ 

流模式是指TCP发送端发送几次数据和接收端接收几次数据是没有必然联系的，比如你通过TCP连接给另一端发送数据，只调用一次write，发送100个字节，但是对方可以分10次收完，每次10个字节；

原因：这是因为TCP是面向连接的，一个 socket 中收到的数据都是由同一台主机发出，且有序地到达，所以每次读取多少数据都可以

#### UDP 叫数据报模式？

数据报模式，是指UDP发送端调用了几次write，接收端必须用相同次数的read读完。UDP是基于报文的，在接收的时候，每次最多只能读取一个报文，报文与报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。

原因：这是因为UDP是无连接的，只要知道接收端的 IP 和端口，任何主机都可以向接收端发送数据。 这时候， 如果一次能读取超过一个报文的数据， 则会乱套。

#### TCP的拥塞控制机制是什么？

- **慢启动：**意思是刚刚加入网络的连接，一点一点地提速，不要一上来就把路占满。
  - 连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。
  - 每当收到一个ACK，cwnd++; 呈线性上升
  - 每当过了一个RTT，cwnd = cwnd*2; 呈指数让升
  - 阈值ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”
- **拥塞避免：**当拥塞窗口 cwnd 达到一个阈值时，窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。
  - 每当收到一个ACK，cwnd = cwnd + 1/cwnd
  - 每当过了一个RTT，cwnd = cwnd + 1
- **拥塞发生：**当发生丢包进行数据包重传时，表示网络已经拥塞。分两种情况进行处理：
  1. 等到RTO超时，重传数据包
     - sshthresh =  cwnd /2
     - cwnd 重置为 1
     - 进入慢启动过程
  2. 在收到3个duplicate ACK时就开启重传，而不用等到RTO超时
     - sshthresh = cwnd = cwnd /2
     - 进入快速恢复算法——Fast Recovery
- **快速恢复：**至少收到了3个Duplicated Acks，说明网络也不那么糟糕，可以快速恢复
  - cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）
  - 重传Duplicated ACKs指定的数据包
  - 如果再收到 duplicated Acks，那么cwnd = cwnd +1
  - 如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。

#### 简述ping原理

简单地说，ping就是给目标IP地址发送一个 ICMP 回显请求，并要求对方返回一个 ICMP 回显应答来确定两台网络机器是否连通，时延是多少。

#### traceroute命令有什么作用？原理是什么？

traceroute命令用于追踪从本机到指定主机的路由途径。 traceroute程序是利用 ICMP 及 IP 头部的 TTL（存活时间）来实现其功能的。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并回复一个「ICMP time exceeded」数据包给发出者。 首先，traceroute发送一个TTL为1的数据包到目的地，当路径上的第一个路由器收到这个数据包时，将它的TTL减1。此时，TTL变为0了，所以该路由器会将此数据包丢掉，并送回一个「ICMP time exceeded」消息，traceroute 收到这个消息后，便知道这个路由器存在于这个路径上。接着traceroute 再送出另一个TTL是2 的数据包，发现第2个路由器…… traceroute 每次将送出的数据包的TTL加1来发现另一个路由器，这个重复的动作一直持续到数据包抵达目的地。 当数据包恰好抵达目的地时，由于traceroute所设置的端口是一个一般应用程序都不会用的号码，所以该主机会回送一个「ICMP port unreachable」的消息，而当traceroute 收到这个端口不可达的ICMP消息时，便知道目的地已经到达了。

#### udp调用connect有什么作用

因为UDP可以是一对一，多对一，一对多，或者多对多通信，所以需要指定目标IP和端口号。通过调用connect建立端到端的连接，就可以和TCP一样使用send/recv传递数据，而不需要每次都指定目标IP和端口号。但是没有三次握手过程。

还可以通过在已建立连接的UDP套接字上，再次调用connect()实现以下功能：  a.指定新的IP地址和端口号。  b.断开连接。  这也与TCP有所不同，TCP套接字只能调用一次connect()函数。

#### connect会阻塞，怎么解决?

最通常的方法最有效的是加定时器；也可以采用非阻塞模式。  设置非阻塞，返回之后用select检测状态)

