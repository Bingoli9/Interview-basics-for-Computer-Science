## 操作系统原理——处理器调度

1、    处理机按照层次被划分为为三级调度

三级调度按照频率从高到低依次被命名为低级调度,中级调度和高级调度

​      低级调度——又称为进程调度,此种调度频率最高.也是最基本的调度。就是cpu不再执行当前进程，而是执行一个就绪态的进程

​      中级调度——又称为交换调度,这种调度就是将内存中暂时不用的进程移至外存.把外存等待的进程调入内存

​      高级调度——又称为作业调度.这种调度频率最低。把等待执行的作业调入内存，并为它创建进程。

​       显然，高级调度的目的是把作业(或者说程序)调入内存，创建进程执行。中级调度是把内存中暂时不执行的进程与外存中等待执行的进程交换，低级调度是把正在执行的进程停止，然后执行就绪等待执行的进程。

​       举个例子——打开了n个游戏，挂了m个qq，因为内存不足，此时打开一个视频播放器发现没有响应，因为作业太多了。此时关掉几个游戏，发现视频播放器自己打开了，这就是作业调度。暂停播放音乐，等待一个小时(因为长时间不调度，这个进程会从内存放入外存)，然后点击继续播放，这个进程又被调入内存执行。被调入内存的过程就是交换调度，而被执行的过程就是进程调度。

2、进程调度

​       进程调度非常频繁，分析进程调度对处理器高效处理非常重要。进程调度会发生进程上下文切换，主要是把当前进程的数据以及执行状态保存(方便下次调用恢复到当前状态)，然后把等待执行的进程的数据放入相关寄存器(注意寄存器与内存区分)，完成切换之后即可执行新调入的进程

调度算法：

先来先服务————按照在链表中的先后顺序执行

优先级调度————根据优先级的高低执行。分为抢占式和非抢占式，抢占式就是如果队列中加入了一个新的高优先级进程，则抢占当前进程进行执行。非抢占式是等待进程执行完之后，在等待执行的队列中找到优先级最高的来执行(不会被强制抢占)

时间片轮转法————每个进程执行一个时间片(大概10ms，具体根据系统而定)，不管是否执行完立即切换进程，保证尽可能多的进程都能被执行

​       其他的算法还有很多，在linux中，主要使用 优先级调度+时间片轮转法 来进行调度，这样既可以保证重要的进程被优先执行(高优先级任务一般比较重要)，也可以保证尽可能多的进程被执行(cpu不会总是被高优先级进程占用)

3、死锁

​        死锁：是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法继续执行，此时称系统处于死锁状态或系统产生了死锁

​        举个例子：两个人(代表两个进程)需要抄作业，A有本和笔却没有借到作业，而B借到了作业却没有本和笔，此时两个人都在等着对方把自己需要的东西送过来。造成两个人一直在等待而无法继续执行，这就是死锁状态。

死锁造成的四个条件：

1、互斥资源(多个进程都需要的资源)。就像例子中的本和笔、借来的作业

2、占有且申请条件。本身占有资源，为了继续执行还需申请资源

3、不可抢占条件。不能强制的获得自己需要申请的资源

4、环路条件。资源申请形成一个环，造成阻塞

死锁的避免：

1、资源最大分配。在执行之前尽可能获得需要的全部资源

2、释放已占资源。在自己无法获得需要申请资源的时候主动放弃已占据资源

避免死锁的经典——银行家算法

(1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客;
(2) 顾客可以分期贷款,但贷款的总数不能超过最大需求量;
(3) 当银行家现有的资金不能满足顾客尚需的贷款数额时,对顾客的贷款可推迟支付,但总能使顾客在有限的时间里得到贷款;
(4) 当顾客得到所需的全部资金后,一定能在有限的时间里归还所有的资金.

​       对进程需求的每一个资源进行模拟分配(满足则分配给它，不满足则不分配)，在模拟分配完之后，进行检验(校验的目的是确保进程获得了它所需要的全部资源)，如果满足则执行模拟分配计划，否则放弃计划(可能有某一个资源不足无法分配)
