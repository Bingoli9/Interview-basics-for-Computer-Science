## 智能指针 Share_ptr

share_ptr 是一个标准的共享所有权的智能指针，允许多个指针指向同一个对象。定义在memory文件中，命名空间为std。

1.  shared_ptr 对象除了包括一个所拥有对象的指针外, 还必须包括一个引用计数代理对象的指针.
2.  时间上的开销主要在初始化和拷贝操作上, *和->操作符重载的开销跟auto_ptr是一样.
3.  开销并不是我们不使用shared_ptr的理由, 永远不要进行不成熟的优化, 直到性能分析器告诉你这一点.

### 成员函数

use_count 返回引用计数的个数
unique 返回是否是独占所有权( use_count 为 1)
swap 交换两个 shared_ptr 对象(即交换所拥有的对象)
reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的

### shared_ptr 的赋值构造函数和拷贝构造函数:

auto r = std::make_shared<int>(); // r 的指向的对象只有一个引用, 其 use_count == 1

auto q = r; (或auto q(r);) // 给 r 赋值, 令其指向另一个地址, q 原来指向的对象的引用计数减1(如果为0, 释放内存), r指向的对象的引用计数加1, 此时 q 与 r 指向同一个对象, 并且其引用计数相同, 都为原来的值加1.

### 何时需要使用 shared_ptr ?

(1) 程序不知道自己需要使用多少对象. 如使用窗口类, 使用 shared_ptr 为了让多个对象能共享相同的底层数据.

(2) 程序不知道所需对象的准确类型.

(3) 程序需要在多个对象间共享数据.

### 自定义释放器(函数)

　　自定义释放器(函数), 它能完成对 shared_ptr 中保存的指针进行释放操作, 还能处理 shared_ptr 的内部对象未完成的部分工作.
