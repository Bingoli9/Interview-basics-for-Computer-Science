## Qt信号与槽实现
  
Qt信号与槽是类似于调用者与回调函数的关系，不同的是，信号槽不在考虑函数指针等比较麻烦的事情，   
槽可以订阅信号，订阅后可以接受信号而不必考虑信号的发送者是谁；发布信号也不必考虑有谁订阅了本    
信号，因此信号槽可以很方便的实现对象之间的通信。  

Qt信号槽可以将信号与普通函数，类的普通成员函数，lambda函数链接。  

### Qt信号槽主要组成 
 
 
#### moc
moc全称为Meta-Object Compiler，元对象编辑器。Qt程序并不使用标准的C++语言，对其进行了一定的扩展。Qt关键字 signals，    
slots或者emit是C++编译器不支持的，所以Qt程序在被C++编译器处理之前，会使用moc分析C++源文件，主要用于处理源文件中    
定义的Q_OBJECT ，SLOT等宏定义，并生成另一份C++源文件，新文件同样进入编译系统，并最终被链接到二进制代码中区。  

#### SIGNAL 和 SLOT宏  
这两个宏的简单定义如下：  
```C++
#define SLOT(a)      "1"#a  
#define SIGNAL(a)    "2"#a  
```
当然，如果需要提供复杂的属性，可以定义更加复杂的宏  

### 元对象
元对象是一个类，主要功能为存储信号和槽的字符串信息，其余附加信息包括：

元对象一般作为类的静态成员。

元对象简单实现为：
```C++
struct MetaObject
{
    const char * sig_names;
    const char * slts_names;
};
```

#### 信号槽链接
在Qt中，信号与槽建立联系是调用connect函数的，这样，当信号被触发的时候，能找到并触发相应的槽。  
```C++
some code
```
connect函数大致思路：  
 - 字符串和信号槽函数关联，这通过宏定义SLOT和SIGNAL宏定义来确定哪些是发送信号函数，哪些是接收槽函数     
 - 元对象保存信号和槽的字符串信息，字符串由上一步骤获得

connect函数的简单实现：
```C++
struct Connection
{
    Object * receiver;
    int method;
};

class Object
{
public:
    static void db_connect(Object*, const char*, Object*, const char*);
private:
    std::multimap<int, Connection> connections;

void Object::db_connect(Object* sender, const char* sig, Object* receiver, const char* slt)
{
    int sig_idx = find_string(sender->meta.sig_names, sig);
    int slt_idx = find_string(receiver->meta.slts_names, slt);
    if (sig_idx == -1 || slt_idx == -1) {
        perror("signal or slot not found!");
    } else {
        Connection c = {receiver, slt_idx};
        sender->connections.insert(std::pair<int, Connection>(sig_idx, c));
    }
}
```
首先从元对象中查找信号和槽的名字是否存在，如果存在，则你那个信号的索引和接受者的信息存入信号发送者的一个map中。如果信号或槽 
无效，就什么都不用做了。   

### 信号的激活


### 槽的调用
上述过程获得的槽函数索引， 可根据索引去调用相应的槽函数。  










