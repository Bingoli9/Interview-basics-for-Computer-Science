## SysTrace

是分析卡顿掉帧问题核心工具，只要能提供卡顿现场，systrace就能很好定位问题  

### 线程运行状态

 systrace上task的运行状态:  
 灰色：Sleeping  
 蓝色：Runnable （它可以运行，但是需要等待调度程序唤醒)  
 绿色：Running  
 橙色：Uninterruptible sleep 由于 I/O 负载而不可中断休眠  
 紫色：可中断的睡眠态 线程在另一个内核操作（通常是内存管理）上被阻塞。  

尤其关注Runnable， 很有可能wake by pid xxx ,  cpu此时被xxx进程抢占着，去看看这个进程是否有什么异常。  

关注点  

我们经常会查看 Running 状态的线程，查看其运行的时间，与竞品做对比，分析快或者慢的原因：
是否频率不够？  
是否跑在了小核上？  
是否频繁在 Running 和 Runnable 之间切换？为什么？  
是否频繁在 Running 和 Sleep 之间切换？为什么？  
是否跑在了不该跑的核上面？比如不重要的线程占用了超大核  

Runnable 状态的线程状态持续时间越长，则表示 cpu 的调度越忙，没有及时处理到这个任务：  
是否后台有太多的任务在跑？  
没有及时处理是因为频率太低？  
没有及时处理是因为被限制到某个 cpuset 里面，但是 cpu 很满？  
此时 Running 的任务是什么？为什么  

线程没有工作要做，可能是因为线程在互斥锁上被阻塞。  

线程在I / O上被阻塞或等待磁盘操作完成，一般底线都会标识出此时的 callsite ：  wait_on_page_locked_killable  

### 渲染帧

用`绿色`框架圆圈表示在16.6毫秒内渲染以保持每秒60帧稳定所需的帧。渲染时间超过16.6毫秒的帧用`黄色`或`红色`框架圆圈表示。  

### 进程唤醒信息分析
一个进程被唤醒的信息往往比较重要，知道他被谁唤醒，那么我们也就知道了他们之间的调用等待关系，如果出现一段比较长的 sleep 情况，然后被唤醒，那么我们就可以去看是谁唤醒了这个线程，对应的就可以查看唤醒者的信息，看看为什么唤醒者这么晚才唤醒。  


### linux 进程状态信息查看
```C++
D 无法中断的休眠状态（通常 IO 的进程）；
R 正在运行可中在队列中可过行的；
S 处于休眠状态；
T 停止或被追踪；
W 进入内存交换 （从内核2.6开始无效）；
X 死掉的进程 （基本很少見）；
Z 僵尸进程；
< 优先级高的进程
N 优先级较低的进程
L 有些页被锁进内存；
s 进程的领导者（在它之下有子进程）；
l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）；
```

### 信息区数据解析
进程状态信息解析  
函数 Slice 信息解析  
Counter Sample 信息解析  
Async Slice 信息解析  
CPU Slice 信息解析  
User Expectation 信息解析  

