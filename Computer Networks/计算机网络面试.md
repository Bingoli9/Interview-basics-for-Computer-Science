#### 七层网络协议

应用层、表示层、会话层、传输层、网络层、链路层、物理层

#### IP层是否有连接状态，维护连接状态的是哪一层

IP层不维护，运输层的TCP维护连接状态。

#### 应用层-TCP-IP-链路层，各个层是什么包

1. 某进程(也就是在应用层)准备好待传输数据，若目的地址是域名则要先通过DNS解析成IP地址
2. 交付到运输层(TCP/UDP层)，运输层通过socket接口对数据进行适当的分组等操作，后对每一个分组数组加上首部形成报文段(或用户数据报)首部包括源地址、源端口、目的地址、目的端口和一些其他的诸如校验和等数据
3. 交付到网际层(IP层)，对分组数据加上首部形成IP数据报，首部包括源地址、目的地址(跟运输层的目的地址不同，运输层的目的地址是数据要传送的最终地址，而该目的地址是通过路由表信息得出，是该数据下一步该转移的目的计算机)和校验和等数据
4. 交付到数据链路层(mac层)，先是对把数据封装成帧(也就是添加首部[SOH]和尾部[EOT])，然后进行透明传输(也就是封装的数据里面，如果出现首部SOH和尾部EOT这样的数据，对其进行转义，也就是加上ESC转义字符，这种方法称为字节/字符填充)
5. 交付到物理层，根据数据链路层的mac知道要传输到目的计算机，通过特定的传输介质传送到下一个地址

#### TCP的三次握手 

第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； 
SYN：同步序列编号(Synchronize Sequence Numbers)
第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； 
第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.

#### 服务器网络请求的接口底层

http协议的底层是在应用层里,是一个特殊处理的socket,建立在TCP/IP协议之上的一种广泛应用

1. 服务器先初始化一个socket, 与端口绑定bind(), 对端口进行监听listen(), 调用阻塞,等待客户端的连接
2. 初始化客户端的socket,与服务器的socket连接,需要经过三次握手
3. 服务器将数据返回给客户端,客户端读取数据,显示在界面上
4. 客户端断开连接需要经过四次握手断开连接

很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。（心跳服务）

#### 四次挥手

1. 客户端向服务器发送一个带有结束标记的报文
2. 服务器接到报文后,向客户端发送一个确认号,同时通知自己相应的应用程序,对方要求断开连接
3. 服务器向客户端发送结束标记的报文
4. 客户端接收到报文后向服务器发送确认序号,断开连接

#### TimeWait状态发生在什么时候

客户机收到服务器带有结束标记的报文时，客户机会对它进行确认，发送响应报文，然后进入TimeWait的状态。

time_wait存在的原因有两点 
1.可靠的终止TCP连接。 
2.保证让迟来的TCP报文段有足够的时间被识别并丢弃。

1.可靠的终止TCP连接，若处于time_wait的client发送给server确认报文段丢失的话，server将在此又一次发送FIN报文段，那么client必须处于一个可接收的状态就是time_wait而不是close状态。 
2.保证迟来的TCP报文段有足够的时间被识别并丢弃，linux 中一个TCP port 不能打开两次或两次以上。当client处于time_wait状态时我们将无法使用此port建立新连接，假设不存在time_wait状态，新连接可能会收到旧连接的数据。

time_wait持续的时间是2MSL，保证旧的数据能够丢弃。由于网络中的数据最大存在MSL(maxinum segment lifetime)

怎样避免time_wait状态占用资源

#### TCP怎么进行可靠传输服务？怎么判断是否重传？（看书吧）

1. 超时
2. 收到3个相同的ack

#### TCP拥塞控制

#### RPC服务器和web服务器的区别，底层的不同（socket， TCP）

#### 服务端发送信息给客户端，要进行数据的序列化，客户端怎么判断哪些数据是在一起？数据是否传输完成？

数据的序列化:

每个包都有一个序列号，当发送方按顺序发出的包乱序到达接收方时（因为走的链路不同），乱序的包会放在接收方的缓存中，先处理按顺序最前的包，或者所有包到达后，重排序，再传给应用层

数据完整性：

头+包体+校验，头部信息可能包括总长度，然后自己接收计算，是否达到总长度

#### TCP的粘包和分包

#### http与https的区别

http协议以明文的方式发送内容，不提供任何方式的数据加密。https协议是安全套接字层超文本协议HTTPS，提供数据传输的安全。HTTPS 在http的基础上加上了SSL协议。

#### https工作原理

客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

- 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
- Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
- 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
- Web服务器利用自己的私钥解密出会话密钥。
- Web服务器利用会话密钥加密与客户端之间的通信。

<center>
    <img src = ""/>
</center>



#### http状态码，301和302的区别。重定向的具体机制。













