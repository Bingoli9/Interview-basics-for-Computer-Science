#### 七层网络协议

应用层、表示层、会话层、传输层、网络层、链路层、物理层

#### IP层是否有连接状态，维护连接状态的是哪一层

IP层不维护，运输层的TCP维护连接状态。

#### 应用层-TCP-IP-链路层，各个层是什么包

1. 某进程(也就是在应用层)准备好待传输数据，若目的地址是域名则要先通过DNS解析成IP地址
2. 交付到运输层(TCP/UDP层)，运输层通过socket接口对数据进行适当的分组等操作，后对每一个分组数组加上首部形成报文段(或用户数据报)首部包括源地址、源端口、目的地址、目的端口和一些其他的诸如校验和等数据
3. 交付到网际层(IP层)，对分组数据加上首部形成IP数据报，首部包括源地址、目的地址(跟运输层的目的地址不同，运输层的目的地址是数据要传送的最终地址，而该目的地址是通过路由表信息得出，是该数据下一步该转移的目的计算机)和校验和等数据
4. 交付到数据链路层(mac层)，先是对把数据封装成帧(也就是添加首部[SOH]和尾部[EOT])，然后进行透明传输(也就是封装的数据里面，如果出现首部SOH和尾部EOT这样的数据，对其进行转义，也就是加上ESC转义字符，这种方法称为字节/字符填充)
5. 交付到物理层，根据数据链路层的mac知道要传输到目的计算机，通过特定的传输介质传送到下一个地址

#### TCP的三次握手 

第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； 
SYN：同步序列编号(Synchronize Sequence Numbers)
第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； 
第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.

#### 服务器网络请求的接口底层

http协议的底层是在应用层里,是一个特殊处理的socket,建立在TCP/IP协议之上的一种广泛应用

1. 服务器先初始化一个socket, 与端口绑定bind(), 对端口进行监听listen(), 调用阻塞,等待客户端的连接
2. 初始化客户端的socket,与服务器的socket连接,需要经过三次握手
3. 服务器将数据返回给客户端,客户端读取数据,显示在界面上
4. 客户端断开连接需要经过四次握手断开连接

很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。（心跳服务）

#### 四次挥手

1. 客户端向服务器发送一个带有结束标记的报文
2. 服务器接到报文后,向客户端发送一个确认号,同时通知自己相应的应用程序,对方要求断开连接
3. 服务器向客户端发送结束标记的报文
4. 客户端接收到报文后向服务器发送确认序号,断开连接

#### TimeWait状态发生在什么时候

客户机收到服务器带有结束标记的报文时，客户机会对它进行确认，发送响应报文，然后进入TimeWait的状态。

time_wait存在的原因有两点 
1.可靠的终止TCP连接。 
2.保证让迟来的TCP报文段有足够的时间被识别并丢弃。

1.可靠的终止TCP连接，若处于time_wait的client发送给server确认报文段丢失的话，server将在此又一次发送FIN报文段，那么client必须处于一个可接收的状态就是time_wait而不是close状态。 
2.保证迟来的TCP报文段有足够的时间被识别并丢弃，linux 中一个TCP port 不能打开两次或两次以上。当client处于time_wait状态时我们将无法使用此port建立新连接，假设不存在time_wait状态，新连接可能会收到旧连接的数据。

time_wait持续的时间是2MSL，保证旧的数据能够丢弃。由于网络中的数据最大存在MSL(maxinum segment lifetime)

怎样避免time_wait状态占用资源

#### TCP怎么进行可靠传输服务？怎么判断是否重传？（看书吧）

1. 超时
2. 收到3个相同的ack

#### TCP拥塞控制

#### RPC服务器和web服务器的区别，底层的不同（socket， TCP）

#### 服务端发送信息给客户端，要进行数据的序列化，客户端怎么判断哪些数据是在一起？数据是否传输完成？

数据的序列化:

每个包都有一个序列号，当发送方按顺序发出的包乱序到达接收方时（因为走的链路不同），乱序的包会放在接收方的缓存中，先处理按顺序最前的包，或者所有包到达后，重排序，再传给应用层

数据完整性：

头+包体+校验，头部信息可能包括总长度，然后自己接收计算，是否达到总长度

#### TCP的粘包和分包

#### http与https的区别

http协议以明文的方式发送内容，不提供任何方式的数据加密。https协议是安全套接字层超文本协议HTTPS，提供数据传输的安全。HTTPS 在http的基础上加上了SSL协议。

#### https工作原理

客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

- 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
- Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
- 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
- Web服务器利用自己的私钥解密出会话密钥。
- Web服务器利用会话密钥加密与客户端之间的通信。

<center>
    <img src = "https://github.com/leekeiling/Interview-basics-for-Computer-Science/blob/master/Computer%20Networks/picture/2012071410212142.gif?raw=true"/>
</center>
HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。



#### http状态码，301和302的区别。重定向的具体机制。

301 redirect: 301 代表永久性转移(Permanently Moved)

302 redirect: 302 代表暂时性转移(Temporarily Moved )

#### TCP三次握手，tcp六个标志位都是什么有什么用

- SYN(synchronous建立联机) 
- ACK(acknowledgement 确认) 
- PSH(push传送) 
- FIN(finish结束) 
- RST(reset重置) 
- URG(urgent紧急)

#### http报文具体结构了解吗，分哪几部分。几种访问请求说一下(get，post，put，patch，delete等)。那这几种哪几种是幂等性的呢。

#### Epoll，poll，select区别。Epoll为什么更快，讲一下具体机制。

1. 功能

   - select会修改描述符，而poll不会
   - select的描述符类型使用数组实现，默认是1024；poll的描述符类型使用链表实现，没有符号数量的限制。
   - poll提供了更多的事件类型，并且对描述符的重复利用比select高
   - 如果一个线程对某个描述符调用了select或者poll，另一个线程关闭了该描述符，会导致调用结果不确定。

2. 速度

   - select和poll每次调用都需要将全部描述符从应用程序缓冲区复制到内核缓冲区
   - select和poll的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于0时，应用进程都需要使用轮询的方式来找到IO完成的描述符。

3. 可移植性

   几乎所有的系统都支持select，只是比较新的系统支持poll

4. 关于epoll

   epoll会向内核注册新的描述符或者改变某个文件描述符的状态。已经注册的描述符在内核中会被维护成一颗红黑树，通过回调函数内核将IO准备好的描述符加入到一个链表中管理，进程调用epoll_wait便可以得到事件完成的描述符。



   epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。

#### IO模式种类

- 阻塞式IO
- 非阻塞式IO
- IO复用(select 和 poll)
- 信号驱动式 IO (SIGIO)
- 异步IO (AIO)

#### epoll的工作模式

1. LT模式

   当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。

2. ET模式

   通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。

   很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

#### HTTP方法

- get：获取资源
- head：获取报文首部
- post：传输实体主体
- put：上传文件
- patch：对资源进行部分修改
- delete：删除文件
- options: 查询支持的方法
- connect：要求在与代理服务器通信时建立隧道
- trace：追踪路径













