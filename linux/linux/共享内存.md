## 共享内存
nmap函数要求内核创建一个新额的虚拟存储器区域，最好是从地址start开始的一个区域，并将文件描述符fd指定为一个连续的pian（chunk）映射到这个新的区域。

SHMMNI为128，表示系统中最多可以有128个共享内存对象。

共享内存是最有用的进程减通信方式，也是最快的IPC形式。两个不同进程A，B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存的改变。 需要同步机制，互斥锁和信号量都可以。

消息队列和管道为什么四次拷贝？
它们是内核对象
	1.由用户空间buf中数据拷贝到内核中。
	2.内核将数据拷贝到内存中
	3.内存到内核
	4.内核到用户空间的buf

共享内存两次拷贝？
	1.用户空间到内存
	2.内存到用户空间

内存怎样保证各个进程寻址到同一个共享内存区域的内存页面。
	1.page cache以及swap cache中页面的区分：一个被访问文件的物理页面都主流在page cache或swap cache中，一个页面的所有信息由page描述。page中有一个域为指针mapping，它指向一个address_space。 page cache或swap cache中的所有页面就是根据address_space结构以及一个偏移量来去区分的。
	2.文件与address_space结构的对应：一个具体文件在打开后，内核会在内存中为之建立一个struct inode结构，其中的i_mapping域指向一个address_space结构偶。这样，一个文件就对应一个address_space结构。一个address_space与一个偏移量能确定一个page cache或swap cache中的一个页面。
	3.进程调用mmap()时，只是在进程空间新增一块缓冲区，并设置了相应的访问标识，但并没有建立进程空间到物理页面的映射。因此，第一次访问该空间时，会引发一个缺页异常。
	4.对于共享内存映射情况，缺页异常处理程序首先在swap cache中寻找目标页（符合address_space以及偏移量的物理页），如果找到，则直接返回地址；如果没有找到，则判断该页是否在交换区(swap area)，如果在，则执行一个换入操作；如果上述两种情况都不满足，处理程序将分配新的物理页面，并把它插入到page cache中。进程最终将更新进程页表。注：对于映射普通文件情况（非共享映射），缺页异常处理程序首先会在page cache中根据address_space以及数据偏移量寻找相应的页面。如果没有找到，则说明文件数据还没有读入内存，处理程序会从磁盘读入相应的页面，并返回相应地址，同时，进程页表也会更新。

###mmap()及其相关系统调用
####void* mmap(void* addr, size_t len, int port, int flags, off_t offset)
mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以访问普通内存一样对文件进行访问。

####系统调用msync()
int msync ( void * addr , size_t len, int flags)
一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。

####系统调用munmap()
int munmap( void * addr, size_t len )
该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。




