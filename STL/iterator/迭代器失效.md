## 迭代器失效

```C++
#include<iostream>
#include<vector>
using namespace std;
int main()
{
    vector<int> v;
    v.push_back(1);

    std::vector<int>::iterator iter1 = v.begin();
    v.push_back(1);

    int n = *iter1;//shit
    cout << n << endl;
    return 0;

}
```

上述代码运行崩溃原因是vector重新分配内存了。

```C++
#include<iostream>
#include<vector>
using namespace std;
int main()
{
vector<int> v;
v.push_back(1);
v.push_back(2);
v.push_back(3);

std::vector<int>::iterator iter1 = v.begin() + 2;
v.erase(v.begin() + 1);
int n = *iter1;

return 0;
}
```
erase 之后迭代器失效

vector迭代器失效情况
- 当插入push_back之后，end操作返回的迭代器失效
- 当插入元素后，capacity返回值与没有插入元素之前相比有改变，需要重新加载整个容器，此时first和end返回迭代器失效
- 当进行删除操作（erase， pop_back)后，指向删除点迭代器全部失效；指向删除点后面的元素迭代器也全部失效
