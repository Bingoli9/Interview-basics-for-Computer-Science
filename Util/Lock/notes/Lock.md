## Lock

### 互斥锁

一条线程加锁锁住临界区，另一条线程尝试访问临界区的 时候，会发生阻塞，并进入休眠状态。临界区是锁lock和unlock之间的代码片段，一般是多条线程共同访问的部分。

### 自旋锁

一条线程加锁锁住临界区，另一条线程尝试访问该临界区的时候会发生阻塞，但是不会进入休眠状态，并且不断轮询该锁，直至原来锁住临界区的线程解锁。

### 读写锁

- 读状态时加锁，此时为共享锁，当一个线程加了读锁时，其他线程如果也尝试以读模式进入临界区，那么不会发生阻塞，直接访问临界区。
- 写状态加锁，此时为独占锁，当某个线程加了写锁，那么其他线程尝试访问该临界区，都会阻塞等待。
- 不加锁
- 某线程加读取锁时，允许其他线程以读模式进入，此时如果有一个线程尝试以写模式访问临界区时，该线程会被阻塞，而其后尝试以读方式访问该临界区的线程也会被阻塞。

### 条件变量

假设有A、B线程，其中A线程加了condwait锁并投入睡眠，而B线程则在某个条件触发，会通过signal通知A，从而唤醒A线程。

### 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。

### 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**
